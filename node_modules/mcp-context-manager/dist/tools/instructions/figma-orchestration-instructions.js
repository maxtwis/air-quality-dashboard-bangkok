/**
 * Figma to Code Orchestration Instructions
 *
 * This module provides comprehensive orchestration instructions for AI agents
 * to achieve pixel-perfect Figma to code conversion through systematic workflows.
 *
 * Core Principle: Orchestrate, don't execute - provide instructions for AI agents
 */
import { generateProductionChecklist } from './figma-production-standards.js';
/**
 * Generate the streamlined production-ready instruction (10/10 quality)
 */
export function generateProductionReadyInstruction() {
    return `# üéØ FIGMA-TO-PRODUCTION AI AGENT INSTRUCTION (10/10)

## CORE OBJECTIVE
Convert Figma MCP response to production-ready React/TypeScript component with pixel-perfect accuracy and enterprise-grade quality standards.

## INPUT PROCESSING RULES

### 1. Figma MCP Data Extraction
\`\`\`typescript
// Required MCP calls (execute in parallel):
const code = await figmaMCP.get_code({ nodeId, clientFrameworks: ["react"], clientLanguages: ["typescript"] });
const image = await figmaMCP.get_image({ nodeId }); // Visual reference
const tokens = await figmaMCP.get_variable_defs({ nodeId }); // Design tokens
\`\`\`

### 2. Value Parsing Priority
1. **Exact values** from style attributes (primary)
2. **CSS custom properties** from design tokens (secondary)
3. **Computed values** from class analysis (fallback)
4. **Never use approximations** - if unsure, extract from Figma measurements

## TRANSFORMATION RULES

### A. Layout Transformation
\`\`\`typescript
// Convert absolute positioning to flexible layout
‚ùå position: absolute; left: 240px; top: 120px;
‚úÖ display: flex; align-items: center; justify-content: flex-start;

// Convert fixed dimensions to responsive constraints
‚ùå width: 600px; height: 400px;
‚úÖ max-width: 600px; width: 100%; min-height: 400px;

// Convert calc() positioning to transform-based
‚ùå left: calc(50% - 100px);
‚úÖ left: 50%; transform: translateX(-50%);
\`\`\`

### B. Responsive Enhancement
\`\`\`typescript
// Add responsive breakpoints
const breakpoints = {
  mobile: "max-width: 640px",
  tablet: "max-width: 1024px", 
  desktop: "min-width: 1025px"
};

// Convert pixel values to responsive units
‚ùå font-size: 24px; padding: 32px;
‚úÖ font-size: clamp(18px, 4vw, 24px); padding: clamp(16px, 4vw, 32px);
\`\`\`

### C. Accessibility Enhancement
\`\`\`typescript
// Add semantic HTML structure
‚ùå <div onClick={handleClick}>Button</div>
‚úÖ <button onClick={handleClick} aria-label="Submit form">Button</button>

// Add keyboard navigation
‚ùå <div className="interactive">
‚úÖ <div className="interactive" tabIndex={0} onKeyDown={handleKeyDown} role="button">

// Add screen reader support
‚ùå <img src="icon.svg" />
‚úÖ <img src="icon.svg" alt="Settings icon" aria-hidden="true" />
\`\`\`

### D. State Management
\`\`\`typescript
// Add complete interactive states
const Component = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  return (
    <button 
      className={\`
        bg-blue-500 hover:bg-blue-600 focus:ring-2 focus:ring-blue-500
        active:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed
        transition-colors duration-200
      \`}
      disabled={isLoading}
      aria-busy={isLoading}
    >
      {isLoading ? 'Processing...' : 'Submit'}
    </button>
  );
};
\`\`\`

## QUALITY STANDARDS (NON-NEGOTIABLE)

### 1. Visual Fidelity Requirements
- **Exact color matching** (no approximations)
- **Precise spacing** (within 1px tolerance)
- **Identical typography** (exact font-size, line-height, letter-spacing)
- **Accurate shadows** (all layers preserved)
- **Proper border radius** (exact values)

### 2. Code Quality Standards
\`\`\`typescript
// TypeScript strict mode compliance
interface ComponentProps {
  title: string;
  onClick: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

// CSS-in-JS with design tokens
const styles = {
  button: {
    backgroundColor: 'var(--color-primary)',
    padding: 'var(--spacing-md)',
    borderRadius: 'var(--radius-md)',
    fontSize: 'var(--font-size-base)',
    fontWeight: 'var(--font-weight-medium)',
  }
};
\`\`\`

### 3. Performance Standards
\`\`\`typescript
// Lazy loading for images
const LazyImage = lazy(() => import('./OptimizedImage'));

// Memoization for expensive computations
const MemoizedComponent = memo(Component);

// CSS optimization
const optimizedStyles = useMemo(() => ({
  transform: \`translate3d(\${x}px, \${y}px, 0)\`, // GPU acceleration
  willChange: 'transform', // Optimize for animations
}), [x, y]);
\`\`\`

### 4. Accessibility Standards
\`\`\`typescript
// WCAG 2.1 AA compliance
const accessibleComponent = {
  'aria-label': 'Descriptive label',
  'role': 'button',
  'tabIndex': 0,
  'aria-pressed': isPressed,
  'aria-disabled': isDisabled,
  'onKeyDown': (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      handleClick();
    }
  }
};
\`\`\`

## OUTPUT SPECIFICATIONS

### 1. File Structure
\`\`\`
ComponentName/
‚îú‚îÄ‚îÄ ComponentName.tsx          # Main component
‚îú‚îÄ‚îÄ ComponentName.styles.ts    # Styled components/CSS modules
‚îú‚îÄ‚îÄ ComponentName.types.ts     # TypeScript interfaces
‚îú‚îÄ‚îÄ ComponentName.test.tsx     # Unit tests
‚îú‚îÄ‚îÄ ComponentName.stories.tsx  # Storybook stories
‚îî‚îÄ‚îÄ index.ts                   # Export barrel
\`\`\`

### 2. Component Template
\`\`\`typescript
import React, { useState, useCallback, memo } from 'react';
import { ComponentNameProps } from './ComponentName.types';
import { styles } from './ComponentName.styles';

export const ComponentName = memo<ComponentNameProps>(({ 
  title, 
  onClick, 
  disabled = false,
  variant = 'primary',
  ...props 
}) => {
  const [isLoading, setIsLoading] = useState(false);
  
  const handleClick = useCallback(async () => {
    if (disabled || isLoading) return;
    
    setIsLoading(true);
    try {
      await onClick();
    } finally {
      setIsLoading(false);
    }
  }, [onClick, disabled, isLoading]);

  return (
    <button
      className={styles.button({ variant, disabled: disabled || isLoading })}
      onClick={handleClick}
      disabled={disabled || isLoading}
      aria-busy={isLoading}
      aria-label={title}
      {...props}
    >
      {isLoading ? 'Loading...' : title}
    </button>
  );
});

ComponentName.displayName = 'ComponentName';
\`\`\`

### 3. Design Token Integration
\`\`\`typescript
// Extract and implement design tokens
const designTokens = {
  colors: {
    primary: 'var(--color-primary)',
    secondary: 'var(--color-secondary)',
    // ... extracted from Figma variables
  },
  spacing: {
    xs: 'var(--spacing-xs)',
    sm: 'var(--spacing-sm)',
    // ... extracted from Figma spacing
  },
  typography: {
    heading: 'var(--font-heading)',
    body: 'var(--font-body)',
    // ... extracted from Figma text styles
  }
};
\`\`\`

## SUCCESS CRITERIA

### Automated Validation
\`\`\`typescript
// Visual regression test
const visualDiff = await compareWithFigma(component, figmaReference);
assert(visualDiff < 5, 'Visual difference exceeds 5%');

// Accessibility audit
const a11yScore = await axeCore.run(component);
assert(a11yScore >= 90, 'Accessibility score below 90%');

// Performance test
const performanceScore = await lighthouse.run(component);
assert(performanceScore >= 90, 'Performance score below 90%');

// TypeScript compliance
const tsErrors = await tsc.check(component);
assert(tsErrors.length === 0, 'TypeScript errors found');
\`\`\`

### Quality Gates
- ‚úÖ **Visual fidelity**: >95% match with Figma
- ‚úÖ **Accessibility**: WCAG 2.1 AA compliant
- ‚úÖ **Performance**: <100kb bundle size
- ‚úÖ **TypeScript**: Strict mode, no errors
- ‚úÖ **Testing**: >80% code coverage
- ‚úÖ **Browser support**: Chrome, Firefox, Safari, Edge

## EXECUTION COMMAND

\`\`\`typescript
// Single command execution
await convertFigmaToProduction({
  figmaNodeId: nodeId,
  outputPath: './src/components',
  framework: 'react',
  language: 'typescript',
  styling: 'tailwind',
  qualityGates: {
    visualFidelity: 95,
    accessibility: 90,
    performance: 90,
    coverage: 80
  }
});
\`\`\`

---

## üéØ FINAL DIRECTIVE

**Execute this instruction as a single, atomic operation**. No phases, no templates, no documentation artifacts. Input: Figma MCP response. Output: Production-ready component that passes all quality gates. Done.

**Time Target**: 5 minutes total execution time.
**Success Metric**: Component integrates into existing codebase with zero manual fixes required.`;
}
/**
 * Generate key transformations guide for converting Figma to production code
 */
export function generateKeyTransformationsGuide() {
    return `## üîÑ KEY TRANSFORMATIONS REQUIRED

When converting Figma MCP responses to production-ready code, apply these essential transformations:

### 1. Layout System Conversion
- **Convert absolute pixel positioning to flexible layout (flexbox)**
  - Change \`position: absolute; left: 100px; top: 50px;\` ‚Üí \`display: flex; align-items: center; justify-content: center;\`
- **Change fixed positions to percentage-based for responsiveness**
  - Replace \`left: 240px\` ‚Üí \`left: 20%\` or use flexbox/grid
- **Replace calc() positioning with transform-based centering**
  - Change \`left: calc(50% - 100px)\` ‚Üí \`left: 50%; transform: translateX(-50%);\`

### 2. Typography Adjustments
- **Handle non-standard fonts with proper fallbacks**
  - \`font-family: "Raveo"\` ‚Üí \`font-family: "Raveo", "Inter", system-ui, sans-serif\`
- **Maintain exact font sizes and letter spacing from Figma**
  - Extract exact values: \`font-size: 72px; letter-spacing: -0.02em;\`
  - Don't use approximations like \`text-6xl\` when precision matters

### 3. Spacing Implementation
- **Add proper margins between elements (often missing in Figma MCP)**
  - Analyze visual design and add: \`margin-bottom: 2rem;\` between sections
- **Create vertical rhythm with consistent spacing**
  - Use spacing scale: \`space-y-8\` for consistent gaps
  - Add padding to containers: \`p-8 md:p-12 lg:p-16\`

### 4. Background Enhancement
- **Add gradient backgrounds (often missing in Figma export)**
  \`\`\`css
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  \`\`\`
- **Properly center background elements with transforms**
  \`\`\`css
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  \`\`\`
- **Add opacity to background elements for visual hierarchy**
  - Background shapes: \`opacity: 0.1\` to \`opacity: 0.3\`

### 5. Responsive Design
- **Add breakpoint-based visibility**
  - \`hidden lg:block\` for desktop-only elements
  - \`block md:hidden\` for mobile-only elements
- **Convert pixel values to responsive units**
  - Fixed widths: \`width: 600px\` ‚Üí \`max-width: 600px; width: 100%;\`
  - Font sizes: Consider \`clamp()\` for fluid typography
- **Add padding for mobile compatibility**
  - Container padding: \`px-4 md:px-8 lg:px-12\`

### 6. Animation System
- **Add motion libraries for enhanced UX**
  - Framer Motion for React: \`motion.div\` with variants
  - CSS animations for simpler effects
- **Create reusable animation variants**
  \`\`\`javascript
  const fadeInUp = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 }
  };
  \`\`\`
- **Implement floating animation for cards**
  \`\`\`css
  @keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
  }
  \`\`\`

### 7. Structural Simplification
- **Remove unnecessary nested divs**
  - Flatten structure where possible
  - Combine transform wrappers
- **Simplify transform wrappers**
  - Multiple nested transforms ‚Üí single transform string
- **Create cleaner component hierarchy**
  - Group related elements
  - Extract reusable components

### 8. Positioning Refinements
- **Convert exact pixel positions to viewport percentages**
  - \`top: 120px\` ‚Üí \`top: 15vh\` or \`top: 10%\`
- **Use modern CSS centering techniques**
  - Flexbox: \`display: flex; place-items: center;\`
  - Grid: \`display: grid; place-content: center;\`
- **Position elements relative to containers, not viewport**
  - Use \`position: relative\` on parent
  - Position children with percentages or flexbox

### TRANSFORMATION CHECKLIST
Before considering the conversion complete:
- [ ] All absolute positions converted to flexible layouts
- [ ] Typography has proper fallbacks and exact values
- [ ] Spacing creates visual hierarchy and rhythm
- [ ] Backgrounds enhanced with gradients and effects
- [ ] Responsive behavior implemented for all breakpoints
- [ ] Animations add polish without affecting performance
- [ ] Structure simplified and components extracted
- [ ] Positioning uses modern, maintainable techniques

## üìã REAL-WORLD TRANSFORMATION EXAMPLE

### What Figma MCP Provides:
\`\`\`jsx
// Absolute positioned elements with exact pixels
<div style={{ position: 'absolute', left: '858px', top: '207px' }}>
  <img src="http://localhost:41001/assets/card.svg" />
</div>

// Background: Simple white
<div className="bg-[#ffffff]">

// Typography without fallbacks
<h1 className="font-['Raveo:Medium',_sans-serif]">

// Complex calc() positioning
<div style={{ left: "calc(50% + 27.2517px)", top: "calc(50% + 320.85px)" }}>
\`\`\`

### What You Should Build:
\`\`\`jsx
// Flexible positioning with percentages
<div className="absolute right-[20%] top-[15%] hidden lg:block">
  <img src="http://localhost:41001/assets/card.svg" />
</div>

// Enhanced gradient background
<div className="bg-gradient-to-br from-[#FFF5F5] via-[#FFF0F8] to-[#F0F4FF]">

// Typography with proper fallbacks
<h1 className="font-['Raveo'] font-medium" style={{ fontFamily: "'Raveo', 'Inter', system-ui, sans-serif" }}>

// Transform-based centering
<div style={{ 
  left: '50%', 
  top: '50%', 
  transform: 'translate(-50%, -50%) translateY(321px)' 
}}>

// Added spacing system
<div className="mb-10">Terminal Icon</div>
<h1 className="mb-8">Heading</h1>
<p className="mb-12">Subtitle</p>

// Animation variants with Framer Motion
const fadeInUp = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] }
  }
};

// Responsive utilities
<div className="px-4 md:px-8 lg:px-12 max-w-4xl mx-auto">
  <div className="hidden lg:block">Desktop only</div>
  <div className="block md:hidden">Mobile only</div>
</div>
\`\`\`

### Summary: The 10-Step Transformation Process

1. **Extract assets** ‚Üí Keep all SVG URLs exactly as provided
2. **Restructure layout** ‚Üí Convert from absolute pixels to flexible system
3. **Add responsiveness** ‚Üí Use percentages and breakpoints
4. **Improve spacing** ‚Üí Add proper margins and padding (mb-8, mb-12, etc.)
5. **Simplify nesting** ‚Üí Remove unnecessary wrapper divs
6. **Add animations** ‚Üí Enhance with Framer Motion or CSS animations
7. **Fix positioning** ‚Üí Use modern CSS techniques for centering
8. **Enhance backgrounds** ‚Üí Add gradients and visual depth
9. **Handle typography** ‚Üí Add fallback fonts and maintain exact values
10. **Maintain visual fidelity** ‚Üí Keep all colors, shadows, and styles from Figma

**Remember**: Figma MCP provides pixel-perfect specifications, but these need to be adapted for responsive web development while maintaining visual accuracy.`;
}
/**
 * Generate transform extraction orchestration instructions
 */
export function generateTransformExtractionOrchestration() {
    return {
        phase: 'TRANSFORM_EXTRACTION',
        instruction: `## üé® 3D TRANSFORM & VISUAL EFFECTS EXTRACTION

This phase guides you through extracting and implementing 3D transforms and visual effects from Figma designs.

### STEP 1: Identify Transform Elements

**AI Agent Task**: Analyze the Figma design for:
1. Elements with rotation (X, Y, or Z axis)
2. Perspective effects on containers
3. Skew or distortion effects
4. Layered depth with shadows
5. Parallax-ready elements

### STEP 2: Extract Transform Values

**AI Agent Task**: For each transformed element:

#### A. Rotation Values
\`\`\`
1. Call: get_code from Figma MCP
2. Look for transform properties
3. Extract:
   - rotateX: {{DEGREES}}
   - rotateY: {{DEGREES}}
   - rotateZ: {{DEGREES}}
   - perspective: {{PIXELS}}
4. Document in transform-map.json
\`\`\`

#### B. Position & Depth
\`\`\`
1. Identify z-index layering
2. Extract translateZ values
3. Map depth relationships:
   {
     "element": "floating-card",
     "depth": 2,
     "transform": "translateZ(20px)",
     "shadow": "0 20px 40px rgba(0,0,0,0.15)"
   }
\`\`\`

#### C. Animation Hints
\`\`\`
1. Detect hover states in Figma
2. Extract transition timings
3. Map animation sequences:
   - Initial state
   - Hover/active state
   - Transition duration
   - Easing function
\`\`\`

### STEP 3: Create Responsive Transform System

**AI Agent Task**: Generate CSS variable system:

\`\`\`css
:root {
  /* Base transform values */
  --perspective-base: {{EXTRACTED_PERSPECTIVE}}px;
  --rotate-x-base: {{EXTRACTED_X}}deg;
  --rotate-y-base: {{EXTRACTED_Y}}deg;
  --rotate-z-base: {{EXTRACTED_Z}}deg;
  
  /* Responsive scaling factors */
  --transform-scale-desktop: 1;
  --transform-scale-tablet: 0.75;
  --transform-scale-mobile: 0.5;
  
  /* Current scale (set by media queries) */
  --transform-scale: var(--transform-scale-desktop);
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  :root {
    --transform-scale: var(--transform-scale-tablet);
  }
}

@media (max-width: 640px) {
  :root {
    --transform-scale: var(--transform-scale-mobile);
  }
}
\`\`\`

### STEP 4: Implement Transform Components

**AI Agent Task**: Create reusable transform utilities:

\`\`\`tsx
// Transform hook for interactive elements
export function use3DTransform(config?: {
  intensity?: number;
  perspective?: number;
}) {
  const [rotation, setRotation] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (e: MouseEvent) => {
    // Calculate rotation based on mouse position
    const rect = e.currentTarget.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    
    setRotation({
      x: (y - 0.5) * 20 * (config?.intensity || 1),
      y: (x - 0.5) * -20 * (config?.intensity || 1)
    });
  };
  
  return {
    style: {
      '--rotate-x': \`\${rotation.x}deg\`,
      '--rotate-y': \`\${rotation.y}deg\`,
      transform: \`
        perspective(var(--perspective-base))
        rotateX(calc(var(--rotate-x) * var(--transform-scale)))
        rotateY(calc(var(--rotate-y) * var(--transform-scale)))
        translateZ(0)
      \`
    },
    onMouseMove: handleMouseMove,
    onMouseLeave: () => setRotation({ x: 0, y: 0 })
  };
}
\`\`\`

### STEP 5: Document Transform Patterns

**AI Agent Task**: Create \`transform-patterns.md\`:

\`\`\`markdown
# Transform Patterns Extracted

## Hero Section 3D Effect
- Perspective: 1200px
- Card rotations: X: -10deg, Y: 15deg
- Responsive scaling: 100% ‚Üí 75% ‚Üí 50%
- Shadow scaling with depth

## Floating Elements Pattern
- Base layout: CSS Grid
- Effect layer: Absolute positioned
- Transform origin: center
- GPU acceleration: translateZ(0)

## Implementation Notes
- All transforms use CSS variables
- Reduced motion respected
- Mobile performance optimized
- Fallback for non-supporting browsers
\`\`\`

### SUCCESS CRITERIA:
‚úÖ All transform values extracted and documented
‚úÖ Responsive scaling system implemented
‚úÖ Performance optimizations applied
‚úÖ Accessibility considerations included
‚úÖ Visual fidelity maintained across devices`,
        template: `{
  "transforms": {
    "element_id": {
      "perspective": "{{PIXELS}}",
      "rotateX": "{{DEGREES}}",
      "rotateY": "{{DEGREES}}",
      "rotateZ": "{{DEGREES}}",
      "translateZ": "{{PIXELS}}",
      "scale": "{{FACTOR}}",
      "origin": "{{X}} {{Y}}"
    }
  },
  "responsive_scaling": {
    "desktop": 1,
    "tablet": {{SCALE}},
    "mobile": {{SCALE}}
  },
  "animations": {
    "hover": {
      "duration": "{{MS}}",
      "easing": "{{FUNCTION}}"
    }
  }
}`
    };
}
/**
 * Generate extraction orchestration instructions
 */
export function generateExtractionOrchestration() {
    return {
        phase: 'EXTRACTION',
        instruction: `## üéØ EXACT VALUE EXTRACTION ORCHESTRATION

This phase guides you through systematic extraction of exact design values from Figma.

### STEP 1: Create Extraction Workflow Document

**AI Agent Task**: Create a new file called \`figma-extraction-log.md\` to document:
1. Each Figma MCP call you make
2. The exact response received
3. Parsing strategies for each value type

### STEP 2: Systematic Value Extraction

**AI Agent Task**: For each design element, follow this extraction process:

#### A. Shadow Extraction
\`\`\`
1. Call: get_code from Figma MCP
2. Search response for: "box-shadow:" 
3. Extract: Each shadow layer separately
4. Document: 
   - Original MCP response
   - Parsed values: {x, y, blur, spread, color, opacity}
   - Any approximations found
\`\`\`

#### B. Gradient Extraction  
\`\`\`
1. Call: get_code AND get_variable_defs from Figma MCP
2. Search for: "background:" containing "gradient"
3. Extract:
   - Gradient type (linear/radial)
   - Angle or position
   - Each color stop with exact position
4. Document all findings with original vs extracted
\`\`\`

#### C. Spacing Extraction
\`\`\`
1. Call: get_code from Figma MCP
2. Search for: All "margin:", "padding:", "gap:" values
3. Parse: Convert any class names to pixel values
4. Create spacing map:
   - Element -> Exact pixel values
   - Note any Tailwind approximations
\`\`\`

#### D. Typography Extraction
\`\`\`
1. Call: get_code from Figma MCP
2. Extract:
   - font-family (exact name)
   - font-size (exact px)
   - font-weight (numeric value)
   - line-height (exact value, not "normal")
   - letter-spacing (exact value)
3. Document any missing values
\`\`\`

### STEP 3: Create Value Mapping Document

**AI Agent Task**: Create \`figma-value-mappings.json\`:
\`\`\`json
{
  "shadows": {
    "button-primary": {
      "mcp_response": "shadow-md",
      "exact_value": "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06)",
      "extraction_method": "Parsed from style attribute in MCP response"
    }
  },
  "colors": {
    "primary": {
      "mcp_response": "blue-600", 
      "exact_value": "#2563EB",
      "opacity": 1
    }
  },
  "spacing": {
    "section-padding": {
      "mcp_response": "p-8",
      "exact_value": "32px",
      "note": "Verify with Figma measurement tool"
    }
  }
}
\`\`\`

### STEP 4: Document Extraction Challenges

**AI Agent Task**: In your extraction log, document:
- Which values required manual verification
- Where MCP approximations differed from exact values  
- Strategies that worked for getting exact values
- Any values that couldn't be extracted

### SUCCESS CRITERIA
‚úì All design values have exact numeric/color values (not utility classes)
‚úì Extraction methods are documented for each value
‚úì Approximations are identified and marked for verification
‚úì Value mapping document is complete and accurate`,
        template: `# FIGMA EXTRACTION LOG

## Component: {{COMPONENT_NAME}}
Date: {{DATE}}
Figma File: {{FIGMA_URL}}

## Extraction Summary

### MCP Calls Made
1. {{MCP_CALL_1}}
   - Response length: {{RESPONSE_LENGTH}}
   - Useful data found: {{DATA_FOUND}}

### Values Extracted

#### Shadows
| Element | MCP Response | Exact Value | Method |
|---------|--------------|-------------|---------|
| {{ELEMENT}} | {{MCP_VALUE}} | {{EXACT_VALUE}} | {{METHOD}} |

#### Colors  
| Element | MCP Response | Exact Value | Opacity | Method |
|---------|--------------|-------------|---------|---------|
| {{ELEMENT}} | {{MCP_VALUE}} | {{HEX_VALUE}} | {{OPACITY}} | {{METHOD}} |

#### Spacing
| Element | Property | MCP Response | Exact Value | Verified |
|---------|----------|--------------|-------------|----------|
| {{ELEMENT}} | {{PROP}} | {{MCP_VALUE}} | {{PX_VALUE}} | {{Y/N}} |

#### Typography
| Element | Property | MCP Response | Exact Value | Note |
|---------|----------|--------------|-------------|-------|
| {{ELEMENT}} | {{PROP}} | {{MCP_VALUE}} | {{EXACT}} | {{NOTE}} |

## Extraction Challenges
1. {{CHALLENGE_1}}
   - Solution: {{SOLUTION_1}}

## Approximations Found
1. {{APPROXIMATION_1}}
   - MCP returned: {{MCP_VALUE}}
   - Actual value: {{ACTUAL_VALUE}}
   - Impact: {{IMPACT}}

## Recommendations for Implementation
{{RECOMMENDATIONS}}`
    };
}
/**
 * Generate validation orchestration instructions
 */
export function generateValidationOrchestration() {
    return {
        phase: 'VALIDATION',
        instruction: `## ‚úÖ VISUAL VALIDATION ORCHESTRATION

This phase guides you through systematic validation of your implementation against the Figma design.

### STEP 1: Create Validation Framework

**AI Agent Task**: Set up validation structure:

1. **Create Validation Checklist** (\`validation-checklist.md\`):
   - List all visual elements to verify
   - Define success criteria for each
   - Create comparison methodology

2. **Prepare Validation Tools**:
   \`\`\`bash
   # Install visual comparison tools
   npm install --save-dev puppeteer pixelmatch pngjs
   
   # Create validation script scaffold
   touch visual-validation.js
   \`\`\`

### STEP 2: Systematic Visual Comparison

**AI Agent Task**: For each component:

#### A. Capture Implementation Screenshot
\`\`\`javascript
// Guide: Add to visual-validation.js
const puppeteer = require('puppeteer');

async function captureImplementation() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  
  // Set viewport to match Figma frame
  await page.setViewport({ width: 1440, height: 900 });
  
  // Navigate to component
  await page.goto('http://localhost:3000/component');
  
  // Wait for render completion
  await page.waitForTimeout(1000);
  
  // Capture screenshot
  await page.screenshot({ path: 'implementation.png' });
  
  await browser.close();
}
\`\`\`

#### B. Obtain Figma Reference
\`\`\`
1. Use: get_image from Figma MCP
2. Save as: figma-reference.png
3. Ensure: Same dimensions as implementation
\`\`\`

#### C. Perform Pixel Comparison
\`\`\`javascript
// Guide: Add comparison logic
const pixelmatch = require('pixelmatch');
const { PNG } = require('pngjs');
const fs = require('fs');

function compareImages() {
  const img1 = PNG.sync.read(fs.readFileSync('implementation.png'));
  const img2 = PNG.sync.read(fs.readFileSync('figma-reference.png'));
  
  const diff = new PNG({ width: img1.width, height: img1.height });
  
  const numDiffPixels = pixelmatch(
    img1.data, 
    img2.data, 
    diff.data, 
    img1.width, 
    img1.height,
    { threshold: 0.1 }
  );
  
  const diffPercentage = (numDiffPixels / (img1.width * img1.height)) * 100;
  
  fs.writeFileSync('diff.png', PNG.sync.write(diff));
  
  return {
    diffPercentage,
    diffPixels: numDiffPixels,
    totalPixels: img1.width * img1.height
  };
}
\`\`\`

### STEP 3: Analyze Differences

**AI Agent Task**: For each difference found:

1. **Identify Mismatch Type**:
   - Color differences
   - Spacing misalignments  
   - Typography variations
   - Shadow inaccuracies

2. **Document in Validation Report**:
   \`\`\`markdown
   ## Validation Report
   
   ### Visual Diff Summary
   - Overall match: {{PERCENTAGE}}%
   - Problem areas: {{COUNT}}
   
   ### Specific Issues
   1. Issue: {{ISSUE_DESCRIPTION}}
      - Location: {{X}}, {{Y}}
      - Expected: {{EXPECTED_VALUE}}
      - Actual: {{ACTUAL_VALUE}}
      - Fix: {{SUGGESTED_FIX}}
   \`\`\`

### STEP 4: Iterative Refinement Process

**AI Agent Task**: For each issue:

1. **Locate in Code**:
   - Find the CSS/component causing the mismatch
   - Identify the specific property

2. **Apply Fix**:
   - Update with exact value from extraction phase
   - Re-run validation

3. **Track Progress**:
   - Document each iteration
   - Note what fixes worked
   - Build pattern library of solutions

### SUCCESS CRITERIA
‚úì Visual diff < 5% for all components
‚úì All critical elements match exactly (text, buttons, key visuals)
‚úì No color mismatches > 2% deviation
‚úì Spacing accurate within 1px tolerance
‚úì Typography matches exactly (size, weight, spacing)`,
        template: `# VISUAL VALIDATION CHECKLIST

## Component: {{COMPONENT_NAME}}
Target Accuracy: 95%+

## Pre-Validation Setup
- [ ] Implementation running at: {{URL}}
- [ ] Figma reference obtained via MCP
- [ ] Viewport size matches Figma frame
- [ ] Visual comparison tools installed

## Elements to Validate

### Critical Elements (Must be 100% match)
- [ ] Primary CTA button
- [ ] Logo/brand elements  
- [ ] Key typography
- [ ] Interactive states

### Colors
| Element | Expected | Actual | Match | Notes |
|---------|----------|---------|--------|--------|
| {{ELEMENT}} | {{FIGMA_COLOR}} | {{IMPL_COLOR}} | {{Y/N}} | {{NOTES}} |

### Spacing
| Measurement | Expected | Actual | Diff | Acceptable |
|-------------|----------|---------|------|------------|
| {{MEASUREMENT}} | {{FIGMA_PX}} | {{IMPL_PX}} | {{DIFF}} | {{Y/N}} |

### Typography
| Property | Expected | Actual | Match | Action |
|----------|----------|---------|--------|---------|
| Font | {{FONT}} | {{FONT}} | {{Y/N}} | {{ACTION}} |
| Size | {{SIZE}} | {{SIZE}} | {{Y/N}} | {{ACTION}} |
| Weight | {{WEIGHT}} | {{WEIGHT}} | {{Y/N}} | {{ACTION}} |
| Line Height | {{LH}} | {{LH}} | {{Y/N}} | {{ACTION}} |

## Validation Results

### Iteration 1
- Date/Time: {{TIMESTAMP}}
- Overall Match: {{PERCENTAGE}}%
- Issues Found: {{COUNT}}
- Critical Issues: {{CRITICAL_COUNT}}

### Issues & Fixes
1. Issue: {{ISSUE}}
   - Fixed: {{Y/N}}
   - Solution: {{SOLUTION}}
   - Iteration: {{NUMBER}}

## Final Validation
- [ ] All critical elements match 100%
- [ ] Overall accuracy > 95%
- [ ] No visible differences at normal viewing distance
- [ ] Approved by: {{APPROVER}}`
    };
}
/**
 * Generate persistence orchestration instructions
 */
export function generatePersistenceOrchestration() {
    return {
        phase: 'PERSISTENCE',
        instruction: `## üíæ KNOWLEDGE PERSISTENCE ORCHESTRATION

This phase ensures all learnings from the Figma-to-code process are captured for future reuse.

### STEP 1: Create Extraction Pattern Library

**AI Agent Task**: Document successful extraction patterns in \`FIGMA-EXTRACTION-PATTERNS.md\`:

\`\`\`markdown
# Figma Extraction Patterns

## Successful MCP Calls

### Shadow Extraction
- **Pattern**: Always use get_code, then search for "box-shadow:" in response
- **Success Rate**: 85% (misses inset shadows)
- **Fallback**: For inset shadows, check style attribute directly

### Gradient Extraction  
- **Pattern**: Combine get_code + get_variable_defs for complete gradient data
- **Success Rate**: 90% (misses some radial gradients)
- **Enhancement**: Parse background CSS property for radial gradients

## Parsing Strategies

### Exact Color Values
1. Search for hex codes in MCP response
2. If found as utility class (e.g., "text-blue-600"):
   - Reference Tailwind color palette
   - Or extract from computed styles
3. Always capture opacity separately

### Spacing Values
1. Utility classes (p-4) -> Use Tailwind spacing scale
2. Arbitrary values ([32px]) -> Extract directly  
3. Calc() expressions -> Preserve as-is

## Common Approximations

| MCP Returns | Actual Value | Detection Method |
|-------------|--------------|-------------------|
| shadow-md | Multiple shadows | Count semicolons in box-shadow |
| rounded-lg | 8px | Check border-radius value |
| text-lg | 18px | Verify font-size |
\`\`\`

### STEP 2: Build Design Token Repository

**AI Agent Task**: Create \`DESIGN-TOKENS-{{PROJECT}}.md\`:

\`\`\`markdown
# Design Tokens - {{PROJECT_NAME}}

## Color Tokens
\`\`\`css
:root {
  /* Primary Palette */
  --color-primary: {{HEX}};
  --color-primary-hover: {{HEX}};
  --color-primary-active: {{HEX}};
  
  /* Neutral Palette */
  --color-gray-50: {{HEX}};
  --color-gray-100: {{HEX}};
  /* ... */
}
\`\`\`

## Spacing Tokens  
\`\`\`css
:root {
  /* Base spacing unit: 4px */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  /* ... */
}
\`\`\`

## Component-Specific Tokens
\`\`\`css
/* Button tokens */
--button-height: {{PX}};
--button-padding-x: {{PX}};
--button-border-radius: {{PX}};
--button-shadow: {{SHADOW_VALUE}};
\`\`\`
\`\`\`

### STEP 3: Create Reusable Conversion Guide

**AI Agent Task**: Document in \`FIGMA-TO-CODE-GUIDE-{{PROJECT}}.md\`:

1. **Project-Specific Patterns**:
   - Component naming conventions
   - State management patterns
   - Animation preferences

2. **Verified Conversions**:
   - Figma components -> Code components mapping
   - Auto-layout -> Flexbox/Grid patterns
   - Effects -> CSS implementation

3. **Gotchas & Solutions**:
   - Platform-specific rendering differences
   - Browser compatibility fixes
   - Performance optimizations applied

### STEP 4: Update Agent Memory

**AI Agent Task**: Add to \`AGENT-MEMORY.md\`:

\`\`\`markdown
## Figma-to-Code Learnings

### Successful Techniques
1. {{TECHNIQUE_1}}
   - Context: {{WHEN_TO_USE}}
   - Success rate: {{PERCENTAGE}}

### Efficiency Improvements  
1. {{IMPROVEMENT_1}}
   - Time saved: {{TIME}}
   - Accuracy impact: {{IMPACT}}

### Tools & Scripts Created
1. {{TOOL_NAME}}
   - Purpose: {{PURPOSE}}
   - Usage: {{HOW_TO_USE}}
\`\`\`

### STEP 5: Create Quick Reference

**AI Agent Task**: Generate \`FIGMA-QUICK-REFERENCE.md\`:

\`\`\`markdown
# Figma-to-Code Quick Reference

## üöÄ Fast Track Steps
1. Initialize: \`npx mcp-context-manager figma_to_code\`
2. Extract: Use saved extraction patterns
3. Implement: Apply design tokens
4. Validate: Run visual-validation.js
5. Refine: Use issue->solution mappings

## üéØ Common Fixes
| Issue | Quick Fix | Verification |
|-------|-----------|--------------|
| Shadow mismatch | Check all layers | Compare with DevTools |
| Color off by shade | Use exact hex | Color picker tool |
| Spacing not exact | Measure in Figma | Alt+hover for spacing |

## üìã Validation Shortcuts
- Diff < 5%: Ship it ‚úÖ
- Diff 5-10%: Check shadows/spacing
- Diff > 10%: Re-extract values
\`\`\`

### SUCCESS CRITERIA
‚úì All extraction patterns documented with success rates
‚úì Complete design token system created
‚úì Project-specific guide captures unique patterns
‚úì Quick reference enables rapid future conversions
‚úì Knowledge persists across sessions`,
        template: `# PERSISTENCE CHECKLIST

## Documents Created
- [ ] FIGMA-EXTRACTION-PATTERNS.md
- [ ] DESIGN-TOKENS-{{PROJECT}}.md  
- [ ] FIGMA-TO-CODE-GUIDE-{{PROJECT}}.md
- [ ] FIGMA-QUICK-REFERENCE.md
- [ ] Updated AGENT-MEMORY.md

## Extraction Patterns Captured
- [ ] Successful MCP call sequences
- [ ] Parsing strategies for each value type
- [ ] Common approximations and solutions
- [ ] Fallback methods documented

## Design System Documentation  
- [ ] All colors extracted and tokenized
- [ ] Spacing system documented
- [ ] Typography scale captured
- [ ] Component-specific tokens defined

## Reusable Assets
- [ ] Visual validation script
- [ ] Token extraction utilities
- [ ] Conversion quick reference
- [ ] Issue->solution mappings

## Knowledge Transfer
- [ ] Can another AI agent use these docs?
- [ ] Are all manual steps documented?
- [ ] Success rates included for techniques?
- [ ] Time-saving tips highlighted?

## Validation
- [ ] Test: Use docs to convert a new component
- [ ] Measure: Time saved vs first attempt
- [ ] Verify: Accuracy maintained or improved`
    };
}
/**
 * Generate Post-MCP implementation guide
 */
function generatePostMCPGuide(params) {
    return `## üö® CRITICAL MINDSET PRINCIPLES

### Principle #1: MCP Responses Are Starting Points, Not Final Solutions
- ‚úÖ **DO**: Use MCP responses as foundation for proper implementation
- ‚ùå **DON'T**: Copy-paste MCP output directly into production
- **WHY**: MCP tools provide approximations that need refinement for pixel-perfect results

### Principle #2: Design Fidelity Requires Manual Refinement
- ‚úÖ **DO**: Cross-reference MCP output with actual Figma design
- ‚ùå **DON'T**: Trust MCP measurements without verification
- **WHY**: MCP tools often round values and miss subtle design details

### Principle #3: Implementation Quality Depends on Post-Processing
- ‚úÖ **DO**: Enhance MCP code with proper ${params.framework} patterns, accessibility, and interactions
- ‚ùå **DON'T**: Ship MCP-generated code without adding missing functionality
- **WHY**: MCP provides structure, but lacks state management, error handling, and user experience details

## üîß COMMON MCP RESPONSE ISSUES TO FIX

### Issue #1: Rounded/Approximated Values
‚ùå **MCP might return**: \`className="h-12 text-lg"\` (48px height, generic text size)
‚úÖ **Extract exact values**: \`className="h-[44px] text-[18px]"\` (Exact Figma measurements)

**Solution Process**:
1. Use Figma's measurement tools to get exact values
2. Replace MCP approximations with precise measurements
3. Test visual accuracy against original design

### Issue #2: Missing Interactive States
‚ùå **MCP typically returns**:
\`\`\`${params.language === 'typescript' ? 'tsx' : 'jsx'}
<button className="bg-blue-500 text-white px-4 py-2 rounded">
  Click me
</button>
\`\`\`

‚úÖ **Add complete state management**:
\`\`\`${params.language === 'typescript' ? 'tsx' : 'jsx'}
<button 
  className="bg-blue-500 hover:bg-blue-600 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 active:bg-blue-700 disabled:opacity-50 transition-colors px-4 py-2 rounded"
  disabled={isLoading}
  aria-pressed={isPressed}
>
  {isLoading ? 'Processing...' : 'Click me'}
</button>
\`\`\`

### Issue #3: Missing Accessibility Features
‚ùå **MCP might return**:
\`\`\`${params.language === 'typescript' ? 'tsx' : 'jsx'}
<div className="cursor-pointer" onClick={handleClick}>
  <img src="icon.svg" />
  <span>Settings</span>
</div>
\`\`\`

‚úÖ **Add accessibility**:
\`\`\`${params.language === 'typescript' ? 'tsx' : 'jsx'}
<button 
  className="flex items-center gap-2 p-2 rounded hover:bg-gray-100"
  onClick={handleClick}
  aria-label="Open settings"
>
  <img src="icon.svg" alt="" aria-hidden="true" />
  <span>Settings</span>
</button>
\`\`\``;
}
/**
 * Generate component tree processing orchestration
 */
export function generateTreeProcessingOrchestration(params) {
    return {
        phase: 'TREE_PROCESSING',
        instruction: `## üå≥ COMPONENT TREE PROCESSING ORCHESTRATION

This phase guides you through automated processing of entire Figma component hierarchies.

### PREREQUISITE SETUP

**AI Agent Task**: Set up Figma API access and tree processing infrastructure:

1. **Create Figma API Configuration** (\`figma-api-config.js\`):
   \`\`\`javascript
   // Store Figma access token securely
   const FIGMA_ACCESS_TOKEN = process.env.FIGMA_ACCESS_TOKEN;
   const FIGMA_FILE_KEY = process.env.FIGMA_FILE_KEY;
   
   // API endpoints
   const FIGMA_API_BASE = 'https://api.figma.com/v1';
   \`\`\`

2. **Install Required Dependencies**:
   \`\`\`bash
   npm install axios p-queue figma-js
   \`\`\`

### STEP 1: Component Tree Discovery

**AI Agent Task**: Implement component tree traversal:

\`\`\`javascript
// tree-processor.js
class FigmaTreeProcessor {
  constructor(fileKey, accessToken) {
    this.fileKey = fileKey;
    this.headers = { 'X-Figma-Token': accessToken };
    this.processedComponents = new Set();
    this.componentMap = new Map();
  }

  async discoverComponentTree(nodeId) {
    // 1. Get node data from Figma API
    const response = await axios.get(
      \`\${FIGMA_API_BASE}/files/\${this.fileKey}/nodes?ids=\${nodeId}\`,
      { headers: this.headers }
    );
    
    const node = response.data.nodes[nodeId];
    
    // 2. Extract component information
    const componentInfo = {
      id: nodeId,
      name: node.document.name,
      type: node.document.type,
      children: [],
      props: this.extractComponentProps(node)
    };
    
    // 3. Process children recursively (${params.processingStrategy})
    ${params.processingStrategy === 'breadth-first' ?
            `await this.processBreadthFirst(node, componentInfo);` :
            `await this.processDepthFirst(node, componentInfo);`}
    
    return componentInfo;
  }
  
  async processDepthFirst(node, componentInfo) {
    if (node.document.children) {
      for (const child of node.document.children) {
        if (this.shouldProcessComponent(child)) {
          const childInfo = await this.discoverComponentTree(child.id);
          componentInfo.children.push(childInfo);
        }
      }
    }
  }
  
  shouldProcessComponent(node) {
    // Apply component filters
    ${params.componentFilter?.types ?
            `if (!${JSON.stringify(params.componentFilter.types)}.includes(node.type)) return false;` : ''}
    ${params.componentFilter?.excludePatterns ?
            `if (${JSON.stringify(params.componentFilter.excludePatterns)}.some(p => node.name.match(p))) return false;` : ''}
    return true;
  }
}
\`\`\`

### STEP 2: Batch Processing Strategy

**AI Agent Task**: Implement efficient batch processing:

\`\`\`javascript
// batch-processor.js
import PQueue from 'p-queue';

class BatchProcessor {
  constructor() {
    // Limit concurrent API calls to respect rate limits
    this.queue = new PQueue({ 
      concurrency: 3, 
      interval: 1000, 
      intervalCap: 10 
    });
    this.results = new Map();
  }
  
  async processComponentBatch(components) {
    const tasks = components.map(component => 
      this.queue.add(async () => {
        try {
          // 1. Get component code via Figma MCP
          const code = await figmaMCP.get_code(component.id);
          
          // 2. Get visual reference
          const image = await figmaMCP.get_image(component.id);
          
          // 3. Extract design tokens
          const tokens = await figmaMCP.get_variable_defs();
          
          // 4. Store results
          this.results.set(component.id, {
            component,
            code,
            image,
            tokens,
            timestamp: new Date().toISOString()
          });
          
          // 5. Log progress
          console.log(\`Processed: \${component.name} (\${component.id})\`);
          
        } catch (error) {
          console.error(\`Failed: \${component.name} - \${error.message}\`);
          this.results.set(component.id, {
            component,
            error: error.message,
            timestamp: new Date().toISOString()
          });
        }
      })
    );
    
    await Promise.all(tasks);
    return this.results;
  }
}
\`\`\`

### STEP 3: Component Relationship Mapping

**AI Agent Task**: Create component dependency graph:

\`\`\`javascript
// component-mapper.js
class ComponentMapper {
  generateComponentMap(treeData) {
    const map = {
      version: '1.0.0',
      timestamp: new Date().toISOString(),
      fileKey: this.fileKey,
      components: {},
      relationships: {},
      statistics: {
        total: 0,
        byType: {},
        maxDepth: 0
      }
    };
    
    // Build comprehensive component map
    this.traverseAndMap(treeData, map, 0);
    
    // Save to component-map.json
    fs.writeFileSync(
      'component-map.json', 
      JSON.stringify(map, null, 2)
    );
    
    return map;
  }
  
  traverseAndMap(node, map, depth) {
    map.components[node.id] = {
      id: node.id,
      name: node.name,
      type: node.type,
      depth: depth,
      parentId: node.parentId || null,
      childIds: node.children.map(c => c.id),
      props: node.props,
      generated: {
        componentPath: \`./components/\${this.sanitizeName(node.name)}/\`,
        exported: \`\${this.toPascalCase(node.name)}\`
      }
    };
    
    // Update statistics
    map.statistics.total++;
    map.statistics.byType[node.type] = (map.statistics.byType[node.type] || 0) + 1;
    map.statistics.maxDepth = Math.max(map.statistics.maxDepth, depth);
    
    // Process children
    node.children.forEach(child => {
      this.traverseAndMap(child, map, depth + 1);
    });
  }
}
\`\`\`

### STEP 4: Progress Tracking & Resilience

**AI Agent Task**: Implement robust progress tracking:

\`\`\`javascript
// progress-tracker.js
class ProgressTracker {
  constructor() {
    this.state = {
      processed: [],
      failed: [],
      skipped: [],
      inProgress: [],
      startTime: Date.now(),
      checkpointFile: '.figma-processing-state.json'
    };
    
    // Load previous state if exists
    this.loadCheckpoint();
  }
  
  loadCheckpoint() {
    if (fs.existsSync(this.state.checkpointFile)) {
      const saved = JSON.parse(fs.readFileSync(this.state.checkpointFile));
      this.state = { ...this.state, ...saved };
      console.log('Resuming from checkpoint...');
    }
  }
  
  saveCheckpoint() {
    fs.writeFileSync(
      this.state.checkpointFile,
      JSON.stringify(this.state, null, 2)
    );
  }
  
  updateProgress(componentId, status, details = {}) {
    // Remove from inProgress
    this.state.inProgress = this.state.inProgress.filter(id => id !== componentId);
    
    // Add to appropriate array
    switch(status) {
      case 'processed':
        this.state.processed.push({ id: componentId, ...details });
        break;
      case 'failed':
        this.state.failed.push({ id: componentId, error: details.error });
        break;
      case 'skipped':
        this.state.skipped.push({ id: componentId, reason: details.reason });
        break;
      case 'in-progress':
        this.state.inProgress.push(componentId);
        break;
    }
    
    // Save checkpoint every 10 components
    if ((this.state.processed.length + this.state.failed.length) % 10 === 0) {
      this.saveCheckpoint();
    }
    
    this.logProgress();
  }
  
  logProgress() {
    const total = this.state.processed.length + 
                  this.state.failed.length + 
                  this.state.skipped.length +
                  this.state.inProgress.length;
    
    console.log(\`
Progress Update:
- Processed: \${this.state.processed.length}
- Failed: \${this.state.failed.length}
- Skipped: \${this.state.skipped.length}
- In Progress: \${this.state.inProgress.length}
- Total: \${total}
- Time Elapsed: \${((Date.now() - this.state.startTime) / 1000).toFixed(1)}s
    \`);
  }
}
\`\`\`

### STEP 5: Component Generation Pipeline

**AI Agent Task**: Generate organized component structure:

\`\`\`javascript
// component-generator.js
class ComponentGenerator {
  async generateFromTree(componentMap, options) {
    // Create base directory structure
    this.createDirectoryStructure();
    
    // Process each component
    for (const [id, component] of Object.entries(componentMap.components)) {
      await this.generateComponent(component, componentMap);
    }
    
    // Generate index files
    await this.generateIndexFiles(componentMap);
    
    // Generate design system
    await this.generateDesignSystem(componentMap);
  }
  
  createDirectoryStructure() {
    const dirs = [
      'generated/components',
      'generated/design-system',
      'generated/tests',
      'generated/docs'
    ];
    
    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }
  
  async generateComponent(component, map) {
    const componentDir = \`generated/\${component.generated.componentPath}\`;
    fs.mkdirSync(componentDir, { recursive: true });
    
    // Generate component files
    const files = {
      component: \`\${component.generated.exported}.tsx\`,
      styles: \`\${component.generated.exported}.styles.ts\`,
      test: \`\${component.generated.exported}.test.tsx\`,
      story: \`\${component.generated.exported}.stories.tsx\`
    };
    
    // Apply production standards to each component
    // ... generation logic following all 15 production standards
  }
}
\`\`\`

### SUCCESS CRITERIA
‚úì All components in tree discovered and mapped
‚úì Batch processing respects API rate limits
‚úì Progress tracking enables resume on failure
‚úì Component relationships preserved
‚úì Generated structure follows production standards
‚úì Design tokens extracted and consolidated

### FILTERING OPTIONS
${params.componentFilter ? `
**Active Filters**:
${params.componentFilter.types ? `- Component Types: ${params.componentFilter.types.join(', ')}` : ''}
${params.componentFilter.maxDepth ? `- Max Depth: ${params.componentFilter.maxDepth}` : ''}
${params.componentFilter.excludePatterns ? `- Exclude Patterns: ${params.componentFilter.excludePatterns.join(', ')}` : ''}
` : 'No filters applied - processing entire tree'}`,
        template: `# COMPONENT TREE PROCESSING LOG

## Processing Configuration
- Strategy: {{PROCESSING_STRATEGY}}
- Start Time: {{START_TIME}}
- Root Component: {{ROOT_COMPONENT}}

## Tree Discovery Results
| Depth | Components Found | Types |
|-------|-----------------|-------|
| {{DEPTH}} | {{COUNT}} | {{TYPES}} |

## Processing Progress
- Total Components: {{TOTAL}}
- Successfully Processed: {{SUCCESS}}
- Failed: {{FAILED}}
- Skipped: {{SKIPPED}}
- Processing Rate: {{RATE}} components/min

## Component Hierarchy
\`\`\`
{{TREE_VISUALIZATION}}
\`\`\`

## Failed Components
| Component | Error | Action Required |
|-----------|-------|-----------------|
| {{NAME}} | {{ERROR}} | {{ACTION}} |

## Generated Structure
\`\`\`
generated/
‚îú‚îÄ‚îÄ components/ ({{COMPONENT_COUNT}} components)
‚îú‚îÄ‚îÄ design-system/
‚îÇ   ‚îú‚îÄ‚îÄ tokens.css
‚îÇ   ‚îî‚îÄ‚îÄ theme.ts
‚îú‚îÄ‚îÄ tests/ ({{TEST_COUNT}} test files)
‚îî‚îÄ‚îÄ component-map.json
\`\`\`

## Next Steps
1. Review failed components
2. Validate generated code
3. Run visual regression tests
4. Deploy component library`
    };
}
/**
 * Generate component mapping system instructions
 */
export function generateComponentMappingInstructions() {
    return {
        phase: 'COMPONENT_MAPPING',
        instruction: `## üó∫Ô∏è COMPONENT MAPPING SYSTEM

This system tracks component relationships and enables intelligent updates.

### STEP 1: Create Mapping Schema

**AI Agent Task**: Define comprehensive mapping structure:

\`\`\`typescript
// types/component-map.ts
interface ComponentMap {
  version: string;
  lastUpdated: string;
  fileKey: string;
  components: Record<string, ComponentEntry>;
  relationships: ComponentRelationships;
  designTokens: DesignTokenMap;
  statistics: ProcessingStats;
}

interface ComponentEntry {
  id: string;
  name: string;
  type: ComponentType;
  figmaNodeId: string;
  lastModified: string;
  hash: string; // For change detection
  generated: {
    path: string;
    exports: string[];
    dependencies: string[];
  };
  variants?: VariantInfo[];
  props?: ComponentProps;
}

interface ComponentRelationships {
  parentChild: Record<string, string[]>;
  compositions: Record<string, string[]>; // Components used within
  shared: Record<string, string[]>; // Shared styles/tokens
}
\`\`\`

### STEP 2: Change Detection System

**AI Agent Task**: Implement incremental update detection:

\`\`\`javascript
// change-detector.js
class ChangeDetector {
  constructor(previousMap, currentMap) {
    this.previous = previousMap;
    this.current = currentMap;
    this.changes = {
      added: [],
      modified: [],
      removed: [],
      unchanged: []
    };
  }
  
  detectChanges() {
    // Check for additions and modifications
    for (const [id, component] of Object.entries(this.current.components)) {
      const prev = this.previous.components[id];
      
      if (!prev) {
        this.changes.added.push(id);
      } else if (prev.hash !== component.hash) {
        this.changes.modified.push({
          id,
          changes: this.compareComponents(prev, component)
        });
      } else {
        this.changes.unchanged.push(id);
      }
    }
    
    // Check for removals
    for (const id of Object.keys(this.previous.components)) {
      if (!this.current.components[id]) {
        this.changes.removed.push(id);
      }
    }
    
    return this.changes;
  }
  
  compareComponents(prev, current) {
    return {
      properties: this.diffProperties(prev.props, current.props),
      variants: this.diffVariants(prev.variants, current.variants),
      dependencies: this.diffArrays(prev.generated.dependencies, current.generated.dependencies)
    };
  }
}
\`\`\`

### STEP 3: Dependency Resolution

**AI Agent Task**: Track and update component dependencies:

\`\`\`javascript
// dependency-resolver.js
class DependencyResolver {
  buildDependencyGraph(componentMap) {
    const graph = new Map();
    
    // Build forward dependencies
    for (const [id, component] of Object.entries(componentMap.components)) {
      graph.set(id, {
        dependsOn: new Set(component.generated.dependencies),
        dependedBy: new Set()
      });
    }
    
    // Build reverse dependencies
    for (const [id, node] of graph.entries()) {
      for (const dep of node.dependsOn) {
        if (graph.has(dep)) {
          graph.get(dep).dependedBy.add(id);
        }
      }
    }
    
    return graph;
  }
  
  getUpdateOrder(changedComponents, dependencyGraph) {
    const updateOrder = [];
    const visited = new Set();
    
    // Topological sort to ensure dependencies update first
    const visit = (id) => {
      if (visited.has(id)) return;
      visited.add(id);
      
      const deps = dependencyGraph.get(id)?.dependsOn || new Set();
      for (const dep of deps) {
        visit(dep);
      }
      
      updateOrder.push(id);
    };
    
    changedComponents.forEach(id => visit(id));
    
    return updateOrder;
  }
}
\`\`\`

### STEP 4: Version Control Integration

**AI Agent Task**: Track component versions:

\`\`\`javascript
// version-tracker.js
class VersionTracker {
  initializeVersioning(componentMap) {
    const versionFile = {
      schemaVersion: '1.0.0',
      components: {},
      history: []
    };
    
    for (const [id, component] of Object.entries(componentMap.components)) {
      versionFile.components[id] = {
        currentVersion: '1.0.0',
        versions: [{
          version: '1.0.0',
          timestamp: new Date().toISOString(),
          hash: component.hash,
          changes: 'Initial version'
        }]
      };
    }
    
    return versionFile;
  }
  
  updateVersion(componentId, changes, versionFile) {
    const component = versionFile.components[componentId];
    const currentVersion = component.currentVersion;
    const newVersion = this.bumpVersion(currentVersion, changes);
    
    component.currentVersion = newVersion;
    component.versions.push({
      version: newVersion,
      timestamp: new Date().toISOString(),
      hash: changes.newHash,
      changes: this.summarizeChanges(changes)
    });
    
    // Add to history
    versionFile.history.push({
      componentId,
      version: newVersion,
      timestamp: new Date().toISOString()
    });
    
    return newVersion;
  }
}
\`\`\`

### SUCCESS CRITERIA
‚úì Complete component inventory maintained
‚úì Change detection identifies all modifications
‚úì Dependencies tracked and resolved correctly
‚úì Version history preserved
‚úì Incremental updates work efficiently`,
        template: `# COMPONENT MAPPING REPORT

## Mapping Summary
- Total Components: {{TOTAL}}
- Component Types: {{TYPES_BREAKDOWN}}
- Max Nesting Depth: {{MAX_DEPTH}}
- Last Updated: {{TIMESTAMP}}

## Change Detection Results
| Status | Count | Components |
|--------|-------|------------|
| Added | {{ADDED_COUNT}} | {{ADDED_LIST}} |
| Modified | {{MODIFIED_COUNT}} | {{MODIFIED_LIST}} |
| Removed | {{REMOVED_COUNT}} | {{REMOVED_LIST}} |
| Unchanged | {{UNCHANGED_COUNT}} | - |

## Dependency Analysis
| Component | Depends On | Depended By |
|-----------|------------|-------------|
| {{COMPONENT}} | {{DEPENDENCIES}} | {{DEPENDENTS}} |

## Update Order
1. {{COMPONENT_1}} - {{REASON}}
2. {{COMPONENT_2}} - {{REASON}}
...

## Version Summary
| Component | Previous | New | Changes |
|-----------|----------|-----|---------|
| {{NAME}} | {{OLD_VER}} | {{NEW_VER}} | {{CHANGES}} |`
    };
}
/**
 * Generate complete orchestration workflow
 */
export function generateCompleteFigmaWorkflow(params) {
    const extraction = generateExtractionOrchestration();
    const transformExtraction = generateTransformExtractionOrchestration();
    const keyTransformations = generateKeyTransformationsGuide();
    const validation = generateValidationOrchestration();
    const persistence = generatePersistenceOrchestration();
    const postMCPGuide = generatePostMCPGuide(params);
    const productionStandards = generateProductionChecklist();
    // Include tree processing if enabled
    const treeProcessing = params.processChildren ?
        generateTreeProcessingOrchestration({
            processingStrategy: params.processingStrategy || 'depth-first',
            componentFilter: params.componentFilter
        }) : null;
    const componentMapping = params.processChildren ?
        generateComponentMappingInstructions() : null;
    return `# üé® COMPLETE FIGMA-TO-CODE ORCHESTRATION WORKFLOW

Component: ${params.componentName}
Framework: ${params.framework} (${params.language})
Styling: ${params.styling}
${params.processChildren ? `
üå≥ **Tree Processing**: ENABLED
- Strategy: ${params.processingStrategy || 'depth-first'}
- Filters: ${params.componentFilter ? JSON.stringify(params.componentFilter) : 'None'}` : ''}

‚ö†Ô∏è **PREREQUISITE**: ${params.processChildren ?
        'Select the root component in Figma Desktop. The entire component tree will be processed automatically.' :
        'Select the component/section in Figma Desktop that you want to implement.'}

## Overview

This orchestration guides AI agents through a systematic process to achieve pixel-perfect, production-ready Figma-to-code conversion${params.processChildren ? ' for entire component hierarchies' : ''}. Follow each phase in order.

---

## PHASE 0: INITIAL MCP EXTRACTION

### Initial Figma MCP Calls
1. **Extract Component Code**:
   \`\`\`
   Use get_code from Figma MCP with:
   - clientName: "cursor"
   - clientFrameworks: ["${params.framework}", "${params.styling}"]
   - clientLanguages: ["${params.language}", "html", "css"]
   \`\`\`

2. **Get Visual Reference**:
   \`\`\`
   Use get_image from Figma MCP to get visual representation
   Save as: figma-reference.png
   \`\`\`

3. **Extract Design System**:
   \`\`\`
   Use get_variable_defs from Figma MCP to get design tokens
   Use get_file_styles from Figma MCP to get style definitions
   \`\`\`

---

${params.processChildren ? `## PHASE 0.5: COMPONENT TREE PROCESSING

${treeProcessing?.instruction}

### Tree Processing Template
\`\`\`markdown
${treeProcessing?.template || ''}
\`\`\`

---

## PHASE 0.6: COMPONENT MAPPING & TRACKING

${componentMapping?.instruction}

### Component Mapping Template
\`\`\`markdown
${componentMapping?.template || ''}
\`\`\`

---

` : ''}## PHASE 1: EXTRACTION ORCHESTRATION

${extraction.instruction}

### Extraction Template
\`\`\`markdown
${extraction.template || ''}
\`\`\`

---

## PHASE 1.5: TRANSFORM & VISUAL EFFECTS EXTRACTION

${transformExtraction.instruction}

### Transform Template
\`\`\`json
${transformExtraction.template || ''}
\`\`\`

---

## PHASE 2: IMPLEMENTATION WITH POST-MCP GUIDE

${postMCPGuide}

---

## PHASE 2.3: KEY TRANSFORMATIONS GUIDE

${keyTransformations}

---

## PHASE 2.5: PRODUCTION CODE STANDARDS

${productionStandards}

---

## PHASE 3: VALIDATION ORCHESTRATION  

${validation.instruction}

### Validation Template
\`\`\`markdown
${validation.template || ''}
\`\`\`

---

## PHASE 4: PERSISTENCE ORCHESTRATION

${persistence.instruction}

### Persistence Template
\`\`\`markdown
${persistence.template || ''}
\`\`\`

---

## üéØ SUCCESS METRICS

### Phase Completion Criteria
- [ ] Initial MCP calls completed and responses saved${params.processChildren ? `
- [ ] Tree Processing: All components discovered and mapped
- [ ] Component Mapping: Relationships and dependencies tracked` : ''}
- [ ] Extraction: 100% of values have exact (non-approximated) values
- [ ] Transform Extraction: All 3D effects and visual transforms captured
- [ ] Implementation: All Post-MCP issues addressed
- [ ] Key Transformations: All 8 transformation categories applied
- [ ] Production Standards: All 16 standards applied and verified
- [ ] Validation: Visual diff < 5% achieved
- [ ] Persistence: All templates filled and knowledge captured

### Overall Success Indicators
- Time to complete: Target < ${params.processChildren ? '2-3 hours for component tree' : '30 minutes for single component'}
- Accuracy achieved: Target > 95% visual match
- Knowledge captured: Can repeat process 50% faster${params.processChildren ? `
- Components processed: All components in tree successfully generated
- Design system: Consolidated tokens extracted from all components` : ''}

## üö® CRITICAL SUCCESS RULES

1. **The Design is ALWAYS Right** - Implement EXACTLY what you see in Figma
2. **NO Hardcoded Values** - Everything must be in CSS variables
3. **NO Fixed Dimensions** - Use min/max constraints with flexible layouts
4. **NO Absolute Positioning for Layout** - Use Grid/Flexbox for structure (visual effects OK)
5. **ALWAYS Accessible** - Semantic HTML, ARIA labels, keyboard navigation
6. **ALWAYS Complete States** - Loading, error, empty, and success states
7. **ALWAYS Production-Ready** - Follow all 16 production standards
8. **Validate Everything** - Test against original design continuously
9. **Preserve Visual Effects** - Implement 3D transforms and effects responsively

## üöÄ IMPLEMENTATION QUICK REFERENCE

**Framework**: ${params.framework} with ${params.language}
**Styling**: ${params.styling}

Remember: The goal is not just to convert this component, but to build a systematic approach that makes all future conversions faster and more accurate. MCP tools accelerate initial implementation, but craftsmanship happens in the refinement stage.`;
}
//# sourceMappingURL=figma-orchestration-instructions.js.map