import { promises as fs } from 'fs';
import { join } from 'path';
import { detectFramework, detectLanguage, detectPatterns } from '../utils/auto-detect.js';
export async function createContextFiles(params) {
    const { projectPath, autoDetect } = params;
    try {
        // Auto-detect project details if enabled
        let projectInfo = {
            name: params.projectName || 'My Project',
            framework: 'unknown',
            language: 'unknown',
            patterns: []
        };
        if (autoDetect) {
            projectInfo = await detectProjectInfo(projectPath);
            if (!params.projectName) {
                projectInfo.name = await detectProjectName(projectPath);
            }
        }
        // Create AI-CONTEXT.md
        const contextContent = generateContextTemplate(projectInfo);
        const contextPath = join(projectPath, 'AI-CONTEXT.md');
        await fs.writeFile(contextPath, contextContent);
        // Create AI-PATTERNS.md
        const patternsContent = generatePatternsTemplate(projectInfo);
        const patternsPath = join(projectPath, 'AI-PATTERNS.md');
        await fs.writeFile(patternsPath, patternsContent);
        return {
            success: true,
            message: `‚úÖ AI Context files created successfully!

üìÅ Files created:
- AI-CONTEXT.md (main context file)
- AI-PATTERNS.md (code patterns and examples)

${autoDetect ? `
üîç Auto-detected:
- Framework: ${projectInfo.framework}
- Language: ${projectInfo.language}
- Patterns: ${projectInfo.patterns.join(', ')}
` : ''}

ACTION: EXECUTE
IMMEDIATE: true

REQUIRED_TASKS:
1. UPDATE all placeholders in ${contextPath}
2. UPDATE all placeholders in ${patternsPath}
3. VERIFY no [PLACEHOLDER] text remains
4. RUN persist_context to enable auto-loading

VALIDATION_CHECKLIST:
- [ ] All [BRACKETED] text replaced with actual values
- [ ] All sections marked (TO BE UPDATED) filled with real data
- [ ] Code examples taken from actual project files
- [ ] No generic placeholders remain

SUCCESS_CRITERIA:
{
  "files_updated": 2,
  "placeholders_remaining": 0,
  "real_examples_added": true
}`,
            filesCreated: [contextPath, patternsPath]
        };
    }
    catch (error) {
        return {
            success: false,
            message: `Failed to create context files: ${error instanceof Error ? error.message : 'Unknown error'}`,
            filesCreated: []
        };
    }
}
async function detectProjectInfo(projectPath) {
    const [framework, language, patterns] = await Promise.all([
        detectFramework(projectPath),
        detectLanguage(projectPath),
        detectPatterns(projectPath)
    ]);
    return {
        name: 'My Project',
        framework,
        language,
        patterns
    };
}
async function detectProjectName(projectPath) {
    try {
        const packageJsonPath = join(projectPath, 'package.json');
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
        return packageJson.name || 'My Project';
    }
    catch {
        // Fallback to directory name
        const parts = projectPath.split('/');
        return parts[parts.length - 1] || 'My Project';
    }
}
function generateContextTemplate(info) {
    return `# AI-CONTEXT.md

This file helps AI assistants understand your project structure, conventions, and patterns.
It's automatically loaded by AI tools to provide consistent context across sessions.

ACTION_REQUIRED: UPDATE_ALL_PLACEHOLDERS
IMMEDIATE: true

## Project Overview

**Project**: ${info.name}
**Framework**: ${info.framework}
**Language**: ${info.language}
**Last Updated**: ${new Date().toISOString().split('T')[0]}

### Description
[REPLACE: Brief description of what this project does]

### Key Features
- [REPLACE: Feature 1]
- [REPLACE: Feature 2]
- [REPLACE: Feature 3]

## Tech Stack

### Core Technologies
- **Framework**: ${info.framework}
- **Language**: ${info.language}
- **Package Manager**: [npm/yarn/pnpm]
- **Build Tool**: [vite/webpack/etc]

### Key Dependencies
- [REPLACE: List main dependencies and their purpose]

## Project Structure

\`\`\`
src/
‚îú‚îÄ‚îÄ components/     # [UI components]
‚îú‚îÄ‚îÄ pages/         # [Page components]
‚îú‚îÄ‚îÄ utils/         # [Utility functions]
‚îú‚îÄ‚îÄ styles/        # [Global styles]
‚îî‚îÄ‚îÄ types/         # [TypeScript types]
\`\`\`

## Development Guidelines

### Code Style
- **Naming**: [DETECT: camelCase/PascalCase conventions from actual code]
- **Components**: [DETECT: Functional/Class components from src/]
- **State Management**: [DETECT: useState/Redux/Context from imports]
- **Styling**: [DETECT: CSS Modules/Styled Components/Tailwind from files]

### Best Practices
1. [EXTRACT: Practice 1 from codebase]
2. [EXTRACT: Practice 2 from codebase]
3. [EXTRACT: Practice 3 from codebase]

### Common Patterns
- **Component Structure**: [ANALYZE: How components are organized]
- **Data Flow**: [ANALYZE: How data flows through the app]
- **Error Handling**: [ANALYZE: How errors are handled]

## API Patterns

### Endpoints
- **Base URL**: [API base URL]
- **Authentication**: [How auth works]
- **Error Format**: [How API errors are structured]

### Common Operations
\`\`\`typescript
// Example API call pattern
[Show typical API call]
\`\`\`

## Testing Strategy

### Test Types
- **Unit Tests**: [Jest/Vitest]
- **Integration Tests**: [Testing Library]
- **E2E Tests**: [Cypress/Playwright]

### Coverage Goals
- Minimum coverage: [X%]
- Critical paths must have tests

## Performance Considerations

### Optimization Strategies
- [Strategy 1]
- [Strategy 2]

### Bundle Size Targets
- Initial load: <[X]kb
- Lazy loaded chunks: <[X]kb

## Security Guidelines

### Authentication
- [How auth is handled]

### Data Protection
- [How sensitive data is protected]

### API Security
- [CORS, rate limiting, etc.]

## Deployment

### Environments
- **Development**: [URL]
- **Staging**: [URL]
- **Production**: [URL]

### CI/CD Pipeline
- [Brief description of deployment process]

## Quick Commands

\`\`\`bash
# Development
npm run dev

# Testing
npm test

# Build
npm run build

# Lint
npm run lint
\`\`\`

## AI Assistant Notes

### When generating code:
1. Follow the patterns in AI-PATTERNS.md
2. Use existing utilities before creating new ones
3. Maintain consistent naming conventions
4. Add appropriate error handling
5. Include TypeScript types

### Common tasks:
- To add a new component: Follow patterns in src/components
- To add an API endpoint: See API patterns above
- To add a test: Match existing test structure

---

## ACTION REQUIRED: COMPLETE THIS FILE

EXECUTE_IMMEDIATELY:
1. READ all project files
2. REPLACE all [REPLACE:], [DETECT:], [EXTRACT:], and [ANALYZE:] markers
3. FILL all bracketed placeholders with actual project data
4. VALIDATE no placeholders remain

VALIDATION:
{
  "action": "CHECK_PLACEHOLDERS",
  "fail_if_found": ["[REPLACE:", "[DETECT:", "[EXTRACT:", "[ANALYZE:", "[", "]"],
  "required": "zero_placeholders"
}

*This file is part of the AI Context system. Update it when project structure changes significantly.*`;
}
function generatePatternsTemplate(info) {
    return `# AI-PATTERNS.md

This file contains code patterns and examples for AI assistants to follow.
These patterns ensure consistency across the codebase.

## Component Patterns

### Basic Component Template
\`\`\`${info.language === 'typescript' ? 'tsx' : 'jsx'}
import React from 'react';

interface ComponentNameProps {
  // Define props here
}

export function ComponentName({ ...props }: ComponentNameProps) {
  return (
    <div>
      {/* Component content */}
    </div>
  );
}
\`\`\`

### Component with State
\`\`\`${info.language === 'typescript' ? 'tsx' : 'jsx'}
import React, { useState } from 'react';

export function StatefulComponent() {
  const [state, setState] = useState(initialValue);
  
  return (
    <div>
      {/* Component content */}
    </div>
  );
}
\`\`\`

### Component with Effects
\`\`\`${info.language === 'typescript' ? 'tsx' : 'jsx'}
import React, { useEffect } from 'react';

export function EffectComponent() {
  useEffect(() => {
    // Effect logic
    return () => {
      // Cleanup
    };
  }, [dependencies]);
  
  return <div />;
}
\`\`\`

## Hook Patterns

### Custom Hook Template
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
import { useState, useEffect } from 'react';

export function useCustomHook(param) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    // Hook logic
  }, [param]);
  
  return { data };
}
\`\`\`

## API Patterns

### API Call Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
export async function fetchData(endpoint: string) {
  try {
    const response = await fetch(\`/api/\${endpoint}\`);
    if (!response.ok) {
      throw new Error('API request failed');
    }
    return await response.json();
  } catch (error) {
    console.error('API Error:', error);
    throw error;
  }
}
\`\`\`

### API Hook Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
export function useApiData(endpoint: string) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchData(endpoint)
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [endpoint]);
  
  return { data, loading, error };
}
\`\`\`

## State Management Patterns

### Context Pattern
\`\`\`${info.language === 'typescript' ? 'tsx' : 'jsx'}
import React, { createContext, useContext, useState } from 'react';

const StateContext = createContext();

export function StateProvider({ children }) {
  const [state, setState] = useState(initialState);
  
  return (
    <StateContext.Provider value={{ state, setState }}>
      {children}
    </StateContext.Provider>
  );
}

export function useAppState() {
  const context = useContext(StateContext);
  if (!context) {
    throw new Error('useAppState must be used within StateProvider');
  }
  return context;
}
\`\`\`

## Error Handling Patterns

### Try-Catch Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
export async function safeOperation() {
  try {
    const result = await riskyOperation();
    return { success: true, data: result };
  } catch (error) {
    console.error('Operation failed:', error);
    return { success: false, error: error.message };
  }
}
\`\`\`

### Error Boundary Pattern
\`\`\`${info.language === 'typescript' ? 'tsx' : 'jsx'}
import React, { Component, ErrorInfo } from 'react';

export class ErrorBoundary extends Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <div>Something went wrong.</div>;
    }
    return this.props.children;
  }
}
\`\`\`

## Testing Patterns

### Component Test Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
import { render, screen } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('renders correctly', () => {
    render(<ComponentName />);
    expect(screen.getByText('expected text')).toBeInTheDocument();
  });
  
  it('handles user interaction', async () => {
    render(<ComponentName />);
    const button = screen.getByRole('button');
    await userEvent.click(button);
    expect(screen.getByText('updated text')).toBeInTheDocument();
  });
});
\`\`\`

### Hook Test Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
import { renderHook } from '@testing-library/react';
import { useCustomHook } from './useCustomHook';

describe('useCustomHook', () => {
  it('returns expected data', () => {
    const { result } = renderHook(() => useCustomHook('param'));
    expect(result.current.data).toBe(expectedValue);
  });
});
\`\`\`

## Style Patterns

### CSS Module Pattern
\`\`\`css
/* ComponentName.module.css */
.container {
  display: flex;
  align-items: center;
  padding: 1rem;
}

.title {
  font-size: 1.5rem;
  font-weight: bold;
}
\`\`\`

### Styled Component Pattern
\`\`\`${info.language === 'typescript' ? 'ts' : 'js'}
import styled from 'styled-components';

export const Container = styled.div\`
  display: flex;
  align-items: center;
  padding: 1rem;
\`;

export const Title = styled.h1\`
  font-size: 1.5rem;
  font-weight: bold;
\`;
\`\`\`

## Type Patterns (TypeScript)

### Interface Pattern
\`\`\`typescript
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
\`\`\`

### Type Guard Pattern
\`\`\`typescript
export function isUser(obj: any): obj is User {
  return (
    typeof obj === 'object' &&
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.email === 'string'
  );
}
\`\`\`

## File Organization Patterns

### Component File Structure
\`\`\`
ComponentName/
‚îú‚îÄ‚îÄ ComponentName.tsx      # Main component
‚îú‚îÄ‚îÄ ComponentName.test.tsx # Tests
‚îú‚îÄ‚îÄ ComponentName.module.css # Styles
‚îú‚îÄ‚îÄ types.ts              # Local types
‚îî‚îÄ‚îÄ index.ts              # Export
\`\`\`

### Feature File Structure
\`\`\`
features/
‚îî‚îÄ‚îÄ user/
    ‚îú‚îÄ‚îÄ components/       # Feature components
    ‚îú‚îÄ‚îÄ hooks/           # Feature hooks
    ‚îú‚îÄ‚îÄ utils/           # Feature utilities
    ‚îú‚îÄ‚îÄ types.ts         # Feature types
    ‚îî‚îÄ‚îÄ index.ts         # Feature exports
\`\`\`

---
*This file is part of the AI Context system. Update it when patterns change.*`;
}
//# sourceMappingURL=setup-context.js.map