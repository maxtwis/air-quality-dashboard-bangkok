/**
 * Instruction Generator for AI Agent Automatic Execution
 *
 * Generates structured commands that AI agents can parse and execute automatically
 * Uses imperative language and explicit action triggers
 *
 * Version 7.1.0 - Automatic execution patterns
 */
/**
 * Generate instruction for AI to analyze codebase
 */
export function generateAnalysisInstruction(projectPath, projectName) {
    return {
        type: 'ANALYZE_CODEBASE',
        projectPath,
        projectName,
        instruction: `
ACTION: EXECUTE
IMMEDIATE: true
PROJECT_PATH: ${projectPath}

REQUIRED_TASKS:
1. READ all source files in ${projectPath}
2. EXTRACT project metadata from package.json
3. IDENTIFY tech stack and dependencies
4. DOCUMENT code patterns with examples
5. COLLECT design tokens from styles
6. REPORT findings in structured format

EXECUTION_SEQUENCE:
{
  "tasks": [
    {
      "id": 1,
      "action": "READ",
      "targets": ["*.ts", "*.tsx", "*.js", "*.jsx", "package.json", "tsconfig.json"],
      "extract": ["file_structure", "imports", "exports", "dependencies"]
    },
    {
      "id": 2,
      "action": "ANALYZE",
      "data_from": "task_1",
      "identify": ["framework", "language", "patterns", "conventions"]
    },
    {
      "id": 3,
      "action": "DOCUMENT",
      "sections": {
        "tech_stack": "{framework} + {language}",
        "dependencies": "{from package.json}",
        "patterns": "{actual code examples}",
        "structure": "{directory tree}"
      }
    }
  ]
}

REQUIRED_OUTPUTS:
- [ ] Tech stack identified (framework + language)
- [ ] Dependencies list extracted
- [ ] 5+ code pattern examples collected
- [ ] File structure documented
- [ ] Naming conventions identified

VALIDATION_RULES:
- MUST read ALL source files
- MUST extract ACTUAL versions from package.json
- MUST include REAL code examples
- MUST NOT use placeholder text

SUCCESS_CRITERIA:
{
  "all_files_read": true,
  "tech_stack_identified": true,
  "examples_collected": ">= 5",
  "placeholders_remaining": 0
}`.trim()
    };
}
/**
 * Generate instruction for AI to update template files
 */
export function generateUpdateInstruction(contextPath) {
    return {
        type: 'UPDATE_TEMPLATES',
        contextPath,
        instruction: `
ACTION: EXECUTE
IMMEDIATE: true
TARGET_PATH: ${contextPath}

REQUIRED_TASKS:
1. UPDATE ${contextPath}/AI-CONTEXT.md
2. UPDATE ${contextPath}/AI-PATTERNS.md  
3. UPDATE ${contextPath}/CLAUDE.md
4. VALIDATE all updates complete

EXECUTION_SEQUENCE:
{
  "tasks": [
    {
      "id": 1,
      "action": "REPLACE",
      "file": "AI-CONTEXT.md",
      "operations": [
        {"find": "[PROJECT_NAME]", "replace": "{actual_project_name}"},
        {"find": "[DETECTED_FRAMEWORK]", "replace": "{identified_framework}"},
        {"find": "[DETECTED_LANGUAGE]", "replace": "{identified_language}"},
        {"find": "[TO BE UPDATED AFTER ANALYSIS]", "replace": "{analysis_results}"}
      ]
    },
    {
      "id": 2,
      "action": "INSERT",
      "file": "AI-PATTERNS.md",
      "sections": {
        "components": "{real_component_examples}",
        "hooks": "{real_hook_examples}",
        "api_calls": "{real_api_patterns}",
        "tests": "{real_test_examples}"
      }
    },
    {
      "id": 3,
      "action": "VALIDATE",
      "checks": [
        "no_placeholders_remain",
        "all_sections_have_content",
        "examples_are_from_codebase"
      ]
    }
  ]
}

REQUIRED_REPLACEMENTS:
- [ ] Replace ALL text in square brackets []
- [ ] Replace ALL text in curly braces marked as placeholder
- [ ] Insert REAL code examples from project
- [ ] Update EVERY section marked (TO BE UPDATED)

VALIDATION_RULES:
- IF placeholder found THEN task = FAILED
- IF section empty THEN task = INCOMPLETE
- IF example not from project THEN task = INVALID

SUCCESS_CRITERIA:
{
  "placeholders_found": 0,
  "empty_sections": 0,
  "real_examples_used": true,
  "all_files_updated": true
}`.trim()
    };
}
/**
 * Generate instruction for dependency checking
 */
export function generateDependencyCheckInstruction(imports, methods, patterns) {
    return {
        type: 'CHECK_DEPENDENCIES',
        target: imports.concat(methods).join(', '),
        instruction: `
ACTION: EXECUTE
IMMEDIATE: true

REQUIRED_CHECKS:
${imports.map((imp, i) => `${i + 1}. VERIFY import "${imp}" exists in project`).join('\n')}
${methods.map((method, i) => `${imports.length + i + 1}. VERIFY method "${method}" is available`).join('\n')}
${patterns ? patterns.map((pattern, i) => `${imports.length + methods.length + i + 1}. VERIFY pattern "${pattern}" is used`).join('\n') : ''}

EXECUTION_SEQUENCE:
{
  "verify_imports": [${imports.map(imp => `"${imp}"`).join(', ')}],
  "verify_methods": [${methods.map(method => `"${method}"`).join(', ')}],
  "verify_patterns": [${patterns ? patterns.map(p => `"${p}"`).join(', ') : ''}]
}

VALIDATION_OUTPUT:
{
  "imports": {
    ${imports.map(imp => `"${imp}": boolean`).join(',\n    ')}
  },
  "methods": {
    ${methods.map(method => `"${method}": boolean`).join(',\n    ')}
  }
}

SUCCESS_CRITERIA:
- ALL imports MUST exist
- ALL methods MUST be available
- NO hallucinated dependencies`.trim()
    };
}
/**
 * Generate instruction for code validation
 */
export function generateCodeValidationInstruction(code, context, targetFile) {
    return {
        type: 'VALIDATE_CODE',
        target: targetFile || 'provided code',
        instruction: `
ACTION: EXECUTE
IMMEDIATE: true

CODE_TO_VALIDATE:
\`\`\`
${code}
\`\`\`

REQUIRED_VALIDATIONS:
1. CHECK pattern compliance
2. VERIFY security requirements
3. VALIDATE TypeScript types
4. ENSURE no hardcoded values
5. CONFIRM error handling

VALIDATION_CHECKLIST:
- [ ] Follows project patterns from AI-PATTERNS.md
- [ ] No security vulnerabilities (no exposed secrets, SQL injection, XSS)
- [ ] TypeScript types properly defined
- [ ] No magic numbers or hardcoded strings
- [ ] Error handling implemented
- [ ] Imports exist in project
- [ ] No deprecated methods used

EXECUTION_SEQUENCE:
{
  "pattern_check": {
    "action": "COMPARE",
    "against": "AI-PATTERNS.md",
    "verify": ["naming", "structure", "style"]
  },
  "security_scan": {
    "action": "SCAN",
    "for": ["secrets", "vulnerabilities", "unsafe_operations"]
  },
  "type_validation": {
    "action": "VERIFY",
    "all_typed": true,
    "no_any": true
  }
}

FAILURE_CONDITIONS:
- Uses different pattern than project standard
- Contains security vulnerability  
- Missing TypeScript types
- Uses hardcoded values
- No error handling

OUTPUT_REQUIRED:
{
  "valid": boolean,
  "issues": string[],
  "fixes_needed": string[]
}`.trim()
    };
}
/**
 * Generate pattern instruction for specific task types
 */
export function generatePatternInstruction(taskType, requirements) {
    const patterns = {
        component: `
ACTION: USE_PATTERN
PATTERN_TYPE: component

REQUIRED_STRUCTURE:
\`\`\`typescript
interface ComponentProps {
  // DEFINE all props with types
}

export function ComponentName({ props }: ComponentProps) {
  // IMPLEMENT component logic
  return (
    // RENDER JSX structure
  );
}
\`\`\`

REQUIREMENTS:
- [ ] TypeScript interface for props
- [ ] Functional component (not class)
- [ ] Proper error boundaries
- [ ] Accessibility attributes`,
        hook: `
ACTION: USE_PATTERN  
PATTERN_TYPE: hook

REQUIRED_STRUCTURE:
\`\`\`typescript
export function useCustomHook(params: ParamType) {
  // IMPLEMENT hook logic
  return {
    // RETURN hook values
  };
}
\`\`\`

REQUIREMENTS:
- [ ] Starts with "use" prefix
- [ ] Handles cleanup in useEffect
- [ ] Returns consistent interface
- [ ] Proper dependency arrays`,
        service: `
ACTION: USE_PATTERN
PATTERN_TYPE: service

REQUIRED_STRUCTURE:
\`\`\`typescript
export class ServiceName {
  // IMPLEMENT service methods
  
  async method(): Promise<ReturnType> {
    try {
      // IMPLEMENT logic
    } catch (error) {
      // HANDLE errors
    }
  }
}
\`\`\`

REQUIREMENTS:
- [ ] Async/await for async operations
- [ ] Try-catch error handling
- [ ] TypeScript return types
- [ ] Dependency injection ready`,
        api: `
ACTION: USE_PATTERN
PATTERN_TYPE: api

REQUIRED_STRUCTURE:
\`\`\`typescript
export async function apiCall(): Promise<ApiResponse> {
  try {
    const response = await fetch(endpoint);
    if (!response.ok) throw new Error();
    return await response.json();
  } catch (error) {
    // HANDLE error
  }
}
\`\`\`

REQUIREMENTS:
- [ ] Error handling for network failures
- [ ] Response validation
- [ ] TypeScript types for response
- [ ] Consistent error format`,
        test: `
ACTION: USE_PATTERN
PATTERN_TYPE: test

REQUIRED_STRUCTURE:
\`\`\`typescript
describe('ComponentName', () => {
  it('should behavior description', () => {
    // ARRANGE
    // ACT
    // ASSERT
  });
});
\`\`\`

REQUIREMENTS:
- [ ] Descriptive test names
- [ ] AAA pattern (Arrange, Act, Assert)
- [ ] Test isolation
- [ ] Edge cases covered`,
        'error-handling': `
ACTION: USE_PATTERN
PATTERN_TYPE: error-handling

REQUIRED_STRUCTURE:
\`\`\`typescript
try {
  // RISKY operation
} catch (error) {
  if (error instanceof SpecificError) {
    // HANDLE specific error
  } else {
    // HANDLE generic error
  }
} finally {
  // CLEANUP if needed
}
\`\`\`

REQUIREMENTS:
- [ ] Specific error types handled
- [ ] User-friendly error messages
- [ ] Error logging implemented
- [ ] Graceful degradation`
    };
    const template = patterns[taskType] || patterns.component;
    const customRequirements = requirements
        ? '\n\nCUSTOM_REQUIREMENTS:\n' + requirements.map(r => `- [ ] ${r}`).join('\n')
        : '';
    return {
        type: 'GET_PATTERN',
        taskType,
        instruction: `
${template}${customRequirements}

EXECUTION:
1. USE pattern from AI-PATTERNS.md if available
2. APPLY project conventions
3. INCLUDE all required elements
4. VALIDATE against checklist

SUCCESS_CRITERIA:
- Pattern matches project standards
- All requirements checked
- No missing elements`.trim(),
        template
    };
}
//# sourceMappingURL=instruction-generator.js.map