import { promises as fs } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
export async function setupPersistence(params) {
    const { projectPath, syncMode, gitHooks } = params;
    try {
        // Check if context files exist
        const contextPath = join(projectPath, 'AI-CONTEXT.md');
        try {
            await fs.access(contextPath);
        }
        catch {
            return {
                success: false,
                message: '‚ùå No context files found. Run setup_context first.',
                setupTools: []
            };
        }
        // Auto-detect tools if not specified
        const detectedTools = params.tools || await detectInstalledTools(projectPath);
        const setupTools = [];
        const setupInstructions = [];
        // Setup for each tool
        if (detectedTools.includes('cursor') || detectedTools.includes('all')) {
            setupInstructions.push(await setupCursor(projectPath, syncMode));
            setupTools.push('cursor');
        }
        if (detectedTools.includes('claude-code') || detectedTools.includes('all')) {
            setupInstructions.push(await setupClaudeCode(projectPath));
            setupTools.push('claude-code');
        }
        if (detectedTools.includes('copilot') || detectedTools.includes('all')) {
            setupInstructions.push(await setupCopilot(projectPath, syncMode));
            setupTools.push('copilot');
        }
        if (detectedTools.includes('continue') || detectedTools.includes('all')) {
            setupInstructions.push(await setupContinue(projectPath, syncMode));
            setupTools.push('continue');
        }
        // Setup git hooks if requested
        let gitHookMessage = '';
        if (gitHooks) {
            gitHookMessage = await setupGitHooks(projectPath);
        }
        // Setup file watcher instructions
        const watcherInstructions = syncMode === 'watch' ? `
üì° FILE WATCHER SETUP:

To keep context files in sync automatically, add this to your package.json scripts:

\`\`\`json
"scripts": {
  "watch:context": "nodemon --watch AI-CONTEXT.md --watch AI-PATTERNS.md --exec 'npm run sync:context'",
  "sync:context": "cp AI-CONTEXT.md .cursorrules && cp AI-PATTERNS.md .github/copilot-instructions.md"
}
\`\`\`

Then run: \`npm run watch:context\` in a separate terminal.` : '';
        return {
            success: true,
            message: `‚úÖ PERSISTENCE SETUP COMPLETE!

üîß Configured for: ${setupTools.join(', ')}

${setupInstructions.join('\n\n')}

${gitHookMessage}

${watcherInstructions}

üìã MANUAL SETUP INSTRUCTIONS:

1. **Verify Setup**:
   - Open each AI tool and check if context loads
   - Make a test change to verify sync works

2. **Keep Context Fresh**:
   - Run \`update_context\` when project changes significantly
   - Git hooks will remind you on commits

3. **Troubleshooting**:
   - If context doesn't load, check file permissions
   - Ensure AI tools have access to project directory
   - For Claude Code, context is accessed via MCP

‚ú® Your AI tools now have persistent memory of your project!`,
            setupTools
        };
    }
    catch (error) {
        return {
            success: false,
            message: `Failed to setup persistence: ${error instanceof Error ? error.message : 'Unknown error'}`,
            setupTools: []
        };
    }
}
async function detectInstalledTools(projectPath) {
    const tools = [];
    // Check for Cursor
    if (await fileExists(join(projectPath, '.cursor'))) {
        tools.push('cursor');
    }
    // Check for VS Code (might have Copilot)
    if (await fileExists(join(projectPath, '.vscode'))) {
        tools.push('copilot');
    }
    // Claude Code is always available if MCP is installed
    tools.push('claude-code');
    // Check for Continue
    if (await fileExists(join(projectPath, '.continue'))) {
        tools.push('continue');
    }
    return tools.length > 0 ? tools : ['all'];
}
async function setupCursor(projectPath, syncMode) {
    const contextPath = join(projectPath, 'AI-CONTEXT.md');
    const cursorRulesPath = join(projectPath, '.cursorrules');
    if (syncMode === 'symlink') {
        try {
            await fs.unlink(cursorRulesPath).catch(() => { });
            await fs.symlink(contextPath, cursorRulesPath);
            return '‚úÖ Cursor: Created symlink .cursorrules ‚Üí AI-CONTEXT.md';
        }
        catch {
            // Fall back to copy
        }
    }
    // Copy mode
    const content = await fs.readFile(contextPath, 'utf-8');
    const cursorContent = `# Cursor Rules (Auto-synced from AI-CONTEXT.md)

${content}

# Additional Cursor-specific rules
- Use tabs for indentation (Cursor preference)
- Suggest completions based on patterns in AI-PATTERNS.md
- Prioritize existing utilities over creating new ones`;
    await fs.writeFile(cursorRulesPath, cursorContent);
    return '‚úÖ Cursor: Created .cursorrules (copy mode)';
}
async function setupClaudeCode(projectPath) {
    const contextPath = join(projectPath, 'AI-CONTEXT.md');
    const patternsPath = join(projectPath, 'AI-PATTERNS.md');
    const claudePath = join(projectPath, 'CLAUDE.md');
    // Check if context files exist
    try {
        await fs.access(contextPath);
        await fs.access(patternsPath);
    }
    catch {
        return '‚ö†Ô∏è Claude Code: AI-CONTEXT.md or AI-PATTERNS.md not found - run setup_context first';
    }
    // Create or update CLAUDE.md with references
    const claudeContent = `# CLAUDE.md

This file is automatically loaded by Claude Code at the start of each conversation.

## üìö Project Context Files

Please read these files for complete project understanding:

1. **[AI-CONTEXT.md](./AI-CONTEXT.md)** - Full project context, tech stack, and guidelines
2. **[AI-PATTERNS.md](./AI-PATTERNS.md)** - Code patterns and examples to follow

## Quick Reference

- **Tech Stack**: Check AI-CONTEXT.md for complete details
- **Code Patterns**: Refer to AI-PATTERNS.md for examples
- **Project Structure**: See AI-CONTEXT.md for directory layout

## Important Notes

- Always follow patterns in AI-PATTERNS.md
- Check AI-CONTEXT.md for project-specific guidelines
- These files are kept up-to-date with \`mcp update_context\`

---
*Last updated: ${new Date().toISOString().split('T')[0]}*`;
    await fs.writeFile(claudePath, claudeContent);
    return '‚úÖ Claude Code: Created CLAUDE.md with references to context files';
}
async function setupCopilot(projectPath, syncMode) {
    const patternsPath = join(projectPath, 'AI-PATTERNS.md');
    const githubDir = join(projectPath, '.github');
    const copilotPath = join(githubDir, 'copilot-instructions.md');
    // Create .github directory if it doesn't exist
    await fs.mkdir(githubDir, { recursive: true });
    if (syncMode === 'symlink') {
        try {
            await fs.unlink(copilotPath).catch(() => { });
            await fs.symlink(patternsPath, copilotPath);
            return '‚úÖ Copilot: Created symlink .github/copilot-instructions.md ‚Üí AI-PATTERNS.md';
        }
        catch {
            // Fall back to copy
        }
    }
    // Copy mode
    const contextContent = await fs.readFile(join(projectPath, 'AI-CONTEXT.md'), 'utf-8');
    const patternsContent = await fs.readFile(patternsPath, 'utf-8');
    const copilotContent = `# GitHub Copilot Instructions

${contextContent}

---

${patternsContent}`;
    await fs.writeFile(copilotPath, copilotContent);
    return '‚úÖ Copilot: Created .github/copilot-instructions.md (combined context + patterns)';
}
async function setupContinue(projectPath, syncMode) {
    const continueDir = join(projectPath, '.continue');
    const continuePath = join(continueDir, 'context.md');
    // Create .continue directory if it doesn't exist
    await fs.mkdir(continueDir, { recursive: true });
    const contextPath = join(projectPath, 'AI-CONTEXT.md');
    if (syncMode === 'symlink') {
        try {
            await fs.unlink(continuePath).catch(() => { });
            await fs.symlink(contextPath, continuePath);
            return '‚úÖ Continue: Created symlink .continue/context.md ‚Üí AI-CONTEXT.md';
        }
        catch {
            // Fall back to copy
        }
    }
    // Copy mode
    const content = await fs.readFile(contextPath, 'utf-8');
    await fs.writeFile(continuePath, content);
    return '‚úÖ Continue: Created .continue/context.md (copy mode)';
}
async function setupGitHooks(projectPath) {
    const gitDir = join(projectPath, '.git');
    // Check if it's a git repository
    try {
        await fs.access(gitDir);
    }
    catch {
        return '‚ö†Ô∏è Git: Not a git repository, skipping hooks';
    }
    const hooksDir = join(gitDir, 'hooks');
    const preCommitPath = join(hooksDir, 'pre-commit');
    const hookContent = `#!/bin/sh
# MCP Context Manager - Context freshness check

# Check if context files exist
if [ -f "AI-CONTEXT.md" ]; then
  # Check last modification time
  CONTEXT_AGE=$(find AI-CONTEXT.md -mtime +7 | wc -l)
  
  if [ $CONTEXT_AGE -gt 0 ]; then
    echo "‚ö†Ô∏è  AI Context files are over 7 days old!"
    echo "   Run 'mcp update_context .' to refresh them."
    echo "   This ensures AI tools have current project knowledge."
    echo ""
  fi
fi

# Continue with commit
exit 0`;
    await fs.writeFile(preCommitPath, hookContent);
    // Make hook executable
    try {
        execSync(`chmod +x "${preCommitPath}"`);
    }
    catch {
        // Windows doesn't need chmod
    }
    return '‚úÖ Git Hooks: Installed pre-commit hook for context freshness checks';
}
async function fileExists(path) {
    try {
        await fs.access(path);
        return true;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=persist-context.js.map